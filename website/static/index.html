<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Algorithms on Regular Expression and Finite Automata</title>
    <link rel="stylesheet" type="text/css" href="./static/layout.css">
    <link rel="stylesheet" type="text/css" href="./static/styles.css">
</head>
<body>

<h1><span id="top">Algorithms on Regular Expression and Finite Automata</span></h1>

<p>
    This website was created to let students use the algorithms developed as part of my
    Master thesis to check their homework and to aid in preparing for their exams.
    Please be aware that for now all queries are executed on the server.
    Therefore, there are strict rate and runtime limits in place to
    protect my webspace and to ensure the user experience of other students.
</p>

<nav>
    <ul>
        <li><a href="#sectionRegularExpressionLanguage">Regular Expression Language</a></li>
        <li><a href="#sectionDerivativesRegularExpressions">Derivatives of Regular Expressions</a></li>
        <li><a href="#sectionRegularExpressionEquivalence">Checking Equivalence of Regular Expressions</a></li>
        <li><a href="#sectionConvertingToDfas">Converting Regular Expressions to DFAs</a></li>
        <li><a href="#sectionFiniteAutomataLanguage">Language for describing Finite Automata</a></li>
        <li><a href="#sectionFiniteAutomataEquivalence">Checking Equivalence of Finite Automata</a></li>
    </ul>
</nav>

<p>
    The code is licenced under a BSD3-license and available on
    <a target="_blank"
       href="https://github.com/koflerdavid/nfa-equivalence-code">its GitHub page</a>.
    Issue reports and pull requests are always welcome :)
</p>

<h2>
    <span id="sectionRegularExpressionLanguage">Regular Expression Language</span>
    <a class="top-link" href="#top">Top</a>
</h2>

<p>
    Regular expressions are composed of the tokens in the following list.
    Tokens can, but are not required to, be separated by any amount of whitespaces.
</p>

<ul>
    <li>
        <code>0</code>, <code>&emptyset;</code>, or <code>&apos;&apos;</code>
        represent the empty language.
    </li>
    <li>
        <code>1</code> or <code>&epsilon;</code>
        represent the language with only the empty word.
    </li>
    <li>
        The characters <code>&lpar;&rpar;&ast;&plus;&vert;&quest;</code>
        are operators.
    </li>
    <li>
        Any character, enclosed in single quotes (<code>&apos;</code>),
        represents the language with that character as the only word.
        This is useful to represent characters that have a special meaning
        according to the other rules.
    </li>
    <li>
        Any character that is not one of the special characters from the above rules, i.e.,
        <code>&quot;&apos;&lpar;&rpar;&ast;&plus;&vert;&quest;01&emptyset;&epsilon;</code>,
        can be represented by itself, without enclosure in pairs of single quotes.
    </li>
</ul>

<p>
    The tokens defined in the previous list are used to compose larger regular expressions
    out of smaller ones.
    To avoid having to write lots of parentheses, operator precedence rules are assumed:
    postfix operators have the highest precedence, then language concatenation,
    and lastly language union (<code>&</code>).
    Parentheses can be used to enclose expressions and to circumvent operator predecence rules.
</p>

<ul>
    <li>
        The postfix operator <code>&ast;</code> represents the Kleene star operation.
    </li>
    <li>
        The postfix operator <code>&plus;</code> represents the "Kleene plus", e.g.,
        <code>a&plus;</code> can be replaced with <code>aa&ast;</code>.
    </li>
    <li>
        The postfix operator <code>&quest;</code> says that
        the regular expression before it is optional, e.g.,
        <code>a&quest;</code> can be replaced with <code>(a &plus; &epsilon;)</code>.
    </li>
    <li>
        The vertical bar <code>&vert;</code> represents the union of languages.
        (This operator has been chosen instead of <code>&plus;</code>
        to avoid having to deal with an ambigous grammar.)
    </li>
    <li>
        Juxtaposition of regular expressions, i.e., writing them next to each other,
        represents language concatenation.
    </li>
</ul>

<p>
    Examples for valid regular expressions are: <code>a(a|b)&ast;b</code>,
    <code>b&plus;&quest;</code>, <code>'(' (')' | '(' ')' ) ')'</code>.
</p>

<h2>
    <span id="sectionDerivativesRegularExpressions">Derivatives of Regular Expressions</span>
    <a class="top-link" href="#top">Top</a>
</h2>

<form id="frmWordDerivation" method="POST" action="regex/derivation">
    <p class="error-message generic-error-message">
        An error occurred when performing the request. Please try again.
        If the problem persists, contact the site administrator.
    </p>
    <p class="error-message custom-error-message"></p>

    <div class="form-rows">
        <div class="form-row">
            <label for="txtWord">
                Word:
            </label>
            <input name="word" type="text" id="txtWord">
        </div>

        <div class="form-row">
            <label for="txtRegex">
                Regular expression:
            </label>
            <textarea name="regex" rows="5" id="txtRegex"></textarea>
        </div>

        <button type="submit">Derive!</button>

        <div class="form-row output-container" id="divDerivationOutput">
            <label for="wordDerivationOutput">Result:</label>
            <output id="wordDerivationOutput"></output>
        </div>
    </div>
</form>

<h2>
    <span id="sectionRegularExpressionEquivalence">Checking Equivalence of Regular Expressions</span>
    <a class="top-link" href="#top">Top</a>
</h2>

<form id="frmRegexEquivalence" method="post" action="regex/equivalence">
    <p class="error-message generic-error-message">
        An error occurred when performing the request. Please try again.
        If the problem persists, contact the site administrator.
    </p>
    <p class="error-message custom-error-message"></p>

    <div class="form-rows">
        <div class="form-row">
            <label for="txtInputRegex1">Regex 1:</label>
            <input type="text" name="regex1" id="txtInputRegex1"></textarea>
        </div>

        <div class="form-row">
            <label for="txtInputRegex2">Regex 2:</label>
            <input type="text" name="regex2" id="txtInputRegex2">
        </div>

        <button type="submit">Check Equivalence</button>

        <div class="form-row output-container">
            <label>Result:</label>
            <span class="equivalence-result equivalent">Equivalent</span>
            <div class="equivalence-result not-equivalent">
                Not equivalent.
                The following strings are accepted by one of the regular expressions, but not by the other:
                <ul class="witnesses-list">
                </ul>
            </div>
        </div>
    </div>
</form>

<h2>
    <span id="sectionConvertingToDfas">Converting Regular Expressions to DFAs</span>
    <a class="top-link" href="#top">Top</a>
</h2>

<form id="frmRegexToDfa" method="post" action="regex/dfa_conversion">
    <p class="error-message generic-error-message">
        An error occurred when performing the request. Please try again.
        If the problem persists, contact the site administrator.
    </p>
    <p class="error-message custom-error-message"></p>

    <div class="form-rows">
        <div class="form-row">
            <label for="txtInputRegex">Regex:</label>
            <textarea name="regex" rows="5" id="txtInputRegex"></textarea>
        </div>
        <button type="submit">Convert!</button>

        <div class="form-row output-container" id="divDfaOutput">
            <label>DFA:</label>
            <div id="dfaRepresentation"></div>
        </div>
    </div>
</form>

<h2>
    <span id="sectionFiniteAutomataLanguage">Language for describing Finite Automata</span>
    <a class="top-link" href="#top">Top</a>
</h2>

<p>
    Finite automata are specified by listing their transitions and by specifying which states are
    accepting states.
    Each transition consists of an origin state, a transition label,
    which is the input symbol necessary for the transition.
    The transition descriptions are written on their own lines each.
    This is represented by an arrow that points from the origin state to the destination states.
    The input symbol is embedded into the arrow.
    to take place, and one or more destination states.
    A valid transition looks like the following: <code>a -b-> c d</code>, which declares that
    the automaton transitions from <code>a</code> to <code>b</code> (or to <code>c</code>)
    when it receives the input symbol <code>b</code>.
</p>

<p>
    After the transitions and the list of accepting states,
    the user can specify a single constraint that shall be checked.
    The only currently supported constraint is equivalence.
    Two states are considered equivalent if the same sets of input symbol sequences lead to accepting states.
    This is more commonly known as two states accepting the same language.
</p>

<p>
    The following input would be a full example.
    It defines an automaton that consists of six states that are connected
    by transitions labeled by the input symbol <code>a</code>.
    The states <code>x</code> and <code>z</code> both lead to <code>y</code>.
    The state <code>y</code> leads to <code>z</code>,
    and there is also a transition from <code>y</code> to <code>z</code>.
    The states <code>u</code>, <code>v</code>, and <code>w</code> are connected similarly
    (A closer look will reveal that these are actually two automata that were merged
    for the purpose of checking their equivalence).
    Finally, it is established that <code>y</code> and <code>v</code> are accepting states,
    and checking the equivalence of <code>x</code> and <code>u</code> is requested.
</p>

<code>
    x -a-> y<br>
    y -a-> z<br>
    z -a-> x y<br>
    u -a-> w v<br>
    v -a-> w<br>
    w -a-> u<br>
    accept: y v<br>
    check: x = u
</code>

<p>
    For more examples, check out the
    <a href="https://perso.ens-lyon.fr/damien.pous/hknt/">web-appendix of Bonchi and Pous' paper</a>.
</p>

<h2>
    <span id="sectionFiniteAutomataEquivalence">Checking Equivalence of Finite Automata</span>
    <a class="top-link" href="#top">Top</a>
</h2>

<form id="frmAutomataEquivalence" method="post" action="finiteAutomata/equivalence" enctype="text/plain">
    <p class="error-message generic-error-message">
        An error occurred when performing the request. Please try again.
        If the problem persists, contact the site administrator.
    </p>
    <p class="error-message custom-error-message"></p>

    <div class="form-rows">
        <div class="form-row">
            <label for="txtAutomatonEquivalenceSpecification">Automaton and Equivalence Specification:</label>
            <textarea name="input" rows="10" cols="30" id="txtAutomatonEquivalenceSpecification"></textarea>
        </div>
        <button type="submit">Check Equivalence</button>

        <div class="form-row output-container">
            <label>Result:</label>
            <span class="equivalence-result equivalent">Equivalent</span>
            <div class="equivalence-result not-equivalent">
                Not equivalent.
                The following strings are accepted by one of the states, but not by the other:
                <ul class="witnesses-list">
                </ul>
            </div>
        </div>
    </div>
</form>

<script type="application/javascript" src="./static/ajax_form_utilities.js"></script>
<script type="application/javascript">
    'use strict';

    FormUtilities.ajaxifyForm('frmWordDerivation', null,
        function (request, form) {
            if (request.status === 200) {
                FormUtilities.byId('wordDerivationOutput').innerText = request.responseText;
                FormUtilities.byId('divDerivationOutput').style = "visibility: visible;";
            } else if (request.status === 400) {
                FormUtilities.showErrorMessage(form, request.responseText);
            } else {
                FormUtilities.showErrorMessage(form, "Regex derivation error");
                console.error("Regex derivation request error", request);
            }
        },
        function (e, request, form) {
            FormUtilities.showErrorMessage(form, "Request error");
            console.error("Regex derivation request error", request, e);
        });

    FormUtilities.ajaxifyForm('frmRegexEquivalence', null,
        function (request, form) {
            FormUtilities.byClassName(form, 'equivalence-result')
                .forEach(function (element) {
                    element.classList.remove('visible');
                });
            FormUtilities.firstByClassName(form, 'output-container').classList.remove('visible');

            if (request.status === 200) {
                try {
                    const result = JSON.parse(request.responseText)
                        , witnessesContainer = FormUtilities.firstByClassName(form, 'witnesses-list');

                    while (witnessesContainer.firstChild) {
                        witnessesContainer.removeChild(witnessesContainer.firstChild);
                    }

                    FormUtilities.firstByClassName(form, 'output-container').classList.add('visible');

                    if (result['equivalent']) {
                        FormUtilities.firstByClassName(form, 'equivalent').classList.add('visible');
                    } else {
                        FormUtilities.firstByClassName(form, 'not-equivalent').classList.add('visible');

                        result['witnesses'].forEach(function (witness) {
                            const code = document.createElement('code');

                            if (witness === '') {
                                code.innerText = '\u03B5'; // Small Greek Character Epsilon
                            } else {
                                code.innerText = ['"', witness, '"'].join('');
                            }

                            const li = document.createElement('li');
                            li.appendChild(code);
                            witnessesContainer.appendChild(li);
                        });
                    }

                } catch (e) {
                    if (e.name === 'SyntaxError') {
                        FormUtilities.showErrorMessage(form, "Invalid response from server");
                        console.error("Invalid response from server", request);
                    }
                }

            } else if (request.status === 400) {
                FormUtilities.showErrorMessage(form, request.responseText);
            } else {
                FormUtilities.showErrorMessage(form, "Request error");
                console.error("Request error", request);
            }
        });

    FormUtilities.ajaxifyForm('frmRegexToDfa', null,
        function (request, form) {
            if (request.status === 200) {
                FormUtilities.byId('dfaRepresentation').innerHTML = request.responseText;
                FormUtilities.byId('divDfaOutput').style = "visibility: visible;";
            } else {
                FormUtilities.showErrorMessage(form, "Regex conversion error");
                console.error("Regex conversion error", request);
            }
        },
        function (e, request, form) {
            FormUtilities.showErrorMessage(form);
            console.error("Regex conversion request error", request, e);
        },
        function (request) {
            // Request a HTML fragment from the server instead of full HTML
            request.setRequestHeader('X-Embeddable', 'true');
        });

    FormUtilities.ajaxifyForm('frmAutomataEquivalence', null,
        function (request, form) {
            FormUtilities.byClassName(form, 'equivalence-result')
                .forEach(function (element) {
                    element.classList.remove('visible');
                });
            FormUtilities.firstByClassName(form, 'output-container').classList.remove('visible');

            if (request.status === 200) {
                try {
                    const result = JSON.parse(request.responseText)
                        , witnessesContainer = FormUtilities.firstByClassName(form, 'witnesses-list');

                    while (witnessesContainer.firstChild) {
                        witnessesContainer.removeChild(witnessesContainer.firstChild);
                    }

                    FormUtilities.firstByClassName(form, 'output-container').classList.add('visible');

                    if (result['equivalent']) {
                        FormUtilities.firstByClassName(form, 'equivalent').classList.add('visible');
                    } else {
                        FormUtilities.firstByClassName(form, 'not-equivalent').classList.add('visible');

                        result['witnesses'].forEach(function (witness) {
                            const code = document.createElement('code');

                            if (witness === '') {
                                code.innerText = '\u03B5'; // Small Greek Character Epsilon
                            } else {
                                code.innerText = ['"', witness, '"'].join('');
                            }

                            const li = document.createElement('li');
                            li.appendChild(code);
                            witnessesContainer.appendChild(li);
                        });
                    }

                } catch (e) {
                    if (e.name === 'SyntaxError') {
                        FormUtilities.showErrorMessage(form, "Invalid response from server");
                        console.error("Invalid response from server", request);
                    }
                }

            } else if (request.status === 400) {
                FormUtilities.showErrorMessage(form, request.responseText);
            } else {
                FormUtilities.showErrorMessage(form, "Request error");
                console.error("Request error", request);
            }
        },
        function (e, request, form) {
            FormUtilities.showErrorMessage(form);
            console.error("Regex conversion request error", request, e);
        });
</script>
</body>
</html>
