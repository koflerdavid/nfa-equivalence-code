<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Algorithms on Regular Expression and Finite Automata</title>
    <link rel="stylesheet" type="text/css" href="./static/styles.css">
</head>
<body>
<h1>Algorithms on Regular Expression and Finite Automata</h1>

<p>
    This website was created to let students use the algorithms developed as part of my
    Master thesis to check their homework and to aid in preparing for their exams.
    Please be aware that for now all queries are executed on the server.
    Therefore, there are strict rate and runtime limits in place to
    protect my webspace and to ensure the user experience of other students.
</p>

<p>
    The code is licenced under a BSD3-license and available on
    <a target="_blank"
       href="https://github.com/koflerdavid/nfa-equivalence-code">its GitHub page</a>.
    Issue reports and pull requests are always welcome :)
</p>

<h2>Regular Expression Language</h2>

<p>
    Regular expressions are composed of the tokens in the following list.
    Tokens can, but are not required to, be separated by any amount of whitespaces.
</p>

<ul>
    <li>
        <code>0</code>, <code>&emptyset;</code>, or <code>&apos;&apos;</code>
        represent the empty language.
    </li>
    <li>
        <code>1</code> or <code>&epsilon;</code>
        represent the language with only the empty word.
    </li>
    <li>
        The characters <code>&lpar;&rpar;&ast;&plus;&vert;&quest;</code>
        are operators.
    </li>
    <li>
        Any character, enclosed in single quotes (<code>&apos;</code>),
        represents the language with that character as the only word.
        This is useful to represent characters that have a special meaning
        according to the other rules.
    </li>
    <li>
        Any character that is not one of the special characters from the above rules, i.e.,
        <code>&quot;&apos;&lpar;&rpar;&ast;&plus;&vert;&quest;01&emptyset;&epsilon;</code>,
        can be represented by itself, without enclosure in pairs of single quotes.
    </li>
</ul>

<p>
    The tokens defined in the previous list are used to compose larger regular expressions
    out of smaller ones.
    To avoid having to write lots of parentheses, operator precedence rules are assumed:
    postfix operators have the highest precedence, then language concatenation,
    and lastly language union (<code>&</code>).
    Parentheses can be used to enclose expressions and to circumvent operator predecence rules.
</p>

<ul>
    <li>
        The postfix operator <code>&ast;</code> represents the Kleene star operation.
    </li>
    <li>
        The postfix operator <code>&plus;</code> represents the "Kleene plus", e.g.,
        <code>a&plus;</code> can be replaced with <code>aa&ast;</code>.
    </li>
    <li>
        The postfix operator <code>&quest;</code> says that
        the regular expression before it is optional, e.g.,
        <code>a&quest;</code> can be replaced with <code>(a &plus; &epsilon;)</code>.
    </li>
    <li>
        The vertical bar <code>&vert;</code> represents the union of languages.
        (This operator has been chosen instead of <code>&plus;</code>
        to avoid having to deal with an ambigous grammar.)
    </li>
    <li>
        Juxtaposition of regular expressions, i.e., writing them next to each other,
        represents language concatenation.
    </li>
</ul>

<p>
    Examples for valid regular expressions are: <code>a(a|b)&ast;b</code>,
    <code>b&plus;&quest;</code>, <code>'(' (')' | '(' ')' ) ')'</code>.
</p>

<h2>Derivatives of Regular Expressions</h2>

<form id="frmWordDerivation" method="POST" action="/regex/derivation">
    <p class="error-message">
        An error occurred when performing the request. Please try again.
        If the problem persists, contact the site administrator.
    </p>

    <div class="form-rows">
        <div class="form-row">
            <label for="txtWord">
                Word:
            </label>
            <input name="word" type="text" id="txtWord">
        </div>

        <div class="form-row">
            <label for="txtRegex">
                Regular expression:
            </label>
            <textarea name="regex" rows="5" id="txtRegex"></textarea>
        </div>

        <button type="submit">Derive!</button>

        <div class="form-row output-container" id="divDerivationOutput">
            <label for="wordDerivationOutput">Result:</label>
            <output id="wordDerivationOutput"></output>
        </div>
    </div>
</form>

<h2>Converting Regular Expressions to DFAs</h2>

<form id="frmRegexToDfa" method="post" action="regex/dfa_conversion">
    <p class="error-message">
        An error occurred when performing the request. Please try again.
        If the problem persists, contact the site administrator.
    </p>

    <div class="form-rows">
        <div class="form-row">
            <label for="txtInputRegex">Regex:</label>
            <textarea name="regex" rows="5" id="txtInputRegex"></textarea>
        </div>
        <button type="submit">Convert!</button>
        <div class="form-row output-container" id="divDfaOutput">
            <label for="dfaRepresentation">DFA:</label>
            <div id="dfaRepresentation"></div>
        </div>
    </div>
</form>

<script type="application/javascript">
    ajaxifyForm('frmWordDerivation', function () {
        const word = byId('txtWord').value || '';
        const regex = byId('txtRegex').value || 'Îµ';
        return encodeURI('word=' + word) + '&' + encodeURI('regex=' + regex);
    }, function (request, form) {
        if (request.status === 200) {
            hideErrorMessages(form);
            byId('wordDerivationOutput').innerText = request.responseText;
            byId('divDerivationOutput').style = "visibility: visible;";
        } else {
            showErrorMessage(form);
            console.error("Regex derivation request error", request);
        }
    }, function (e, request, form) {
        showErrorMessage(form);
        console.error("Regex derivation request error", request, e);
    });

    ajaxifyForm('frmRegexToDfa', function (form) {
        const regex = byId('txtInputRegex').value || '';
        return encodeURI('regex=' + regex);
    }, function (request, form) {
        if (request.status === 200) {
            hideErrorMessages(form);
            byId('dfaRepresentation').innerHTML = request.responseText;
            byId('divDfaOutput').style = "visibility: visible;";
        } else {
            showErrorMessage(form);
            console.error("Regex conversion request error", request);
        }
    }, function (e, request, form) {
        showErrorMessage(form);
        console.error("Regex conversion request error", request, e);
    }, function (request) {
        // Request a HTML fragment from the server instead of full HTML
        request.setRequestHeader('X-Embeddable', 'true');
    });

    function showErrorMessage(form) {
        byClassName(form, 'error-message')
            .forEach(function (element) {
                element.classList.add('visible');
            });
    }

    function hideErrorMessages(form) {
        byClassName(form, 'error-message')
            .forEach(function (element) {
                element.classList.remove('visible');
            });
    }

    function ajaxifyForm(id, formParser, onSuccess, onError, requestConfigurator) {
        const form = byId(id)
            , action = form.getAttribute('action')
            , method = form.getAttribute('method');

        form.onsubmit = function (e) {
            const request = createRequest(action, method);
            request.addEventListener('load', function () {
                onSuccess(request, form);
            });

            if (requestConfigurator != null) {
                requestConfigurator(request);
            }

            request.addEventListener('error', function (e) {
                onError(e, request, form);
            });

            const encodedFormData = formParser(form);
            request.send(encodedFormData);

            e.preventDefault();
        };
    }

    function byId(id) {
        const element = document.getElementById(id);
        if (element == null) {
            throw new DOMError('Element with id ' + id + ' not found');
        }

        return element;
    }

    function byClassName(element, className) {
        return Array.from(element.getElementsByClassName(className));
    }

    function createRequest(url, method) {
        const request = new XMLHttpRequest();
        request.open(method || 'POST', url, true);
        request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        return request;
    }
</script>
</body>
</html>
